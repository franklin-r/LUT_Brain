/*
 * NNLayer.cpp
 *
 *  Created on: Jul 11, 2013
 *      Author: jpdavid
 */

#include "NNLayer.h"
#include "math.h"
#include "stdio.h"
#include "stdlib.h"
#include "Image.h"

#define MAKE_TERNARY_THRESHOLD 0.3

NNLayer::NNLayer() {
	// TODO Auto-generated constructor stub
	n_input = 0;
	n_neuron = 0;
	n_input_per_neuron = 0;
	LUT_size = 0;

	LUT_array = 0;
	pos_array = 0;
	value = 0;
}

NNLayer::NNLayer(int new_n_input, int new_n_neuron, int nipn) {
	// TODO Auto-generated constructor stub
	init(new_n_input, new_n_neuron, nipn);
}

void NNLayer::init(int new_n_input, int new_n_neuron, int nipn) {
	// TODO Auto-generated constructor stub
	n_input = new_n_input;
	n_neuron = new_n_neuron;
	n_input_per_neuron = nipn;
	LUT_size = ((1<<nipn) + 7)/8;
	LUT_array = new char[n_neuron*LUT_size];
	pos_array = new char[n_neuron*n_input_per_neuron];
	value = new float[n_neuron];
}

int MYrand() {
	static unsigned long seed=0x1234567;
	seed = seed * 3196829161;
	return seed >> 1;
}

// max must be a power of 2
int MYrand(int maxval) {
	return (maxval-1) & MYrand();
}

float NNLayer::rand_FloatRange(float a, float b) {
	return ((b-a)*((float)MYrand()/0x7FFFFFFF))+a;
}

void NNLayer::random_init(int new_n_input, int new_n_neuron, int nipn) {
	// TODO Auto-generated constructor stub
	init(new_n_input, new_n_neuron, nipn);

	for (int i=0; i<n_neuron * LUT_size; i++) {
		LUT_array[i] = MYrand(0x100);
	}

	for (int i=0; i<n_neuron * n_input_per_neuron; i++) {
		pos_array[i] = MYrand(n_input);
	}
}

void NNLayer::demo_init(int layer, int new_n_input, int new_n_neuron, int nipn) {
	// TODO Auto-generated constructor stub
	random_init(new_n_input, new_n_neuron, nipn);
}

NNLayer::~NNLayer() {
	// TODO Auto-generated destructor stub
}

float * NNLayer::propagate(float * source) {
	// TODO Auto-generated constructor stub
	int * current_pos = pos_array;
	for (int i=0; i<n_neuron; i++) {
		int LUT_Address = 0;
		for (int j = 0; j<n_input_per_neuron; j++) {
			if (source[*(current_pos++)] != 0) LUT_Address += (1 << j);
		}
		value[i] = LUT_array[LUT_size * i + (LUT_Address >> 3)] >> (LUT_Address & 0x7);
	}
	return value;
}

void NNLayer::print_activation() {
	printf("---------------\n");
	for (int i=0; i<n_neuron; i++) {
		printf("%i, %i\n", i, (int)value[i]);
	}
}

void NNLayer::print() {
	// TODO Auto-generated constructor stub
	int * current_pos = pos_array;

	for (int i=0; i<n_neuron; i++) {
		printf("Neuron %i { ", i+1);
		for (int j=0; j<n_input; j++) {
			if (j!=0) printf(", %i", *(current_pos++));
			else printf("%i", *(current_pos++));;
		}
		printf("}, %f\r\n",value[i]);
	}
}

